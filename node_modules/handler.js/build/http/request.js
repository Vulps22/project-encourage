"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var net = require("net");
var accepts = require('accepts');
var contentType = require("content-type");
var typeis = require('type-is');
var _accept = new WeakMap();
var _body = new WeakMap();
var _context = new WeakMap();
var _headers = new WeakMap();
var _method = new WeakMap();
var _params = new WeakMap();
var _path = new WeakMap();
var _proxy = new WeakMap();
var _query = new WeakMap();
var _subdomainOffset = new WeakMap();
var _url = new WeakMap();
var HTTPRequest = (function () {
    function HTTPRequest(options) {
        _accept.set(this, accepts(this));
        _body.set(this, options.body);
        _context.set(this, options.context);
        _headers.set(this, options.headers || {});
        _method.set(this, options.method);
        _params.set(this, options.params || {});
        _path.set(this, options.path);
        _proxy.set(this, !!options.proxy);
        _query.set(this, options.query || {});
        _subdomainOffset.set(this, options.subdomainOffset || 0);
    }
    // Check if the given type(s) is acceptable, returning the best match when true, otherwise false.
    // The type value may be one or more mime type string such as "application/json",
    // the extension name such as "json", or an array ["json", "html", "text/plain"].
    //
    // You may call this.accepts() as many times as you like, or use a switch.
    HTTPRequest.prototype.accepts = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        var accept = _accept.get(this);
        return accept.types.apply(accept, arguments);
    };
    // Check if charsets are acceptable, returning the best match when true, otherwise false.
    //
    // When no arguments are given all accepted charsets are returned as an array.
    HTTPRequest.prototype.acceptsCharsets = function () {
        var charsets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            charsets[_i] = arguments[_i];
        }
        var accept = _accept.get(this);
        return accept.charsets.apply(accept, arguments);
    };
    // Check if encodings are acceptable, returning the best match when true, otherwise false.
    // Note that you should include identity as one of the encodings!
    //
    // When no arguments are given all accepted encodings are returned as an array.
    //
    // Note that the identity encoding (which means no encoding) could be unacceptable if the client
    // explicitly sends identity;q=0.
    // Although this is an edge case, you should still handle the case where this method returns false.
    HTTPRequest.prototype.acceptsEncodings = function () {
        var encodings = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            encodings[_i] = arguments[_i];
        }
        var accept = _accept.get(this);
        return accept.encodings.apply(accept, arguments);
    };
    // Check if langs are acceptable, returning the best match when true, otherwise false.
    //
    // When no arguments are given all accepted languages are returned as an array.
    HTTPRequest.prototype.acceptsLanguages = function () {
        var langs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            langs[_i] = arguments[_i];
        }
        var accept = _accept.get(this);
        return accept.languages.apply(accept, arguments);
    };
    Object.defineProperty(HTTPRequest.prototype, "body", {
        // Get body.
        get: function () {
            return _body.get(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "charset", {
        // Get request charset when present, or undefined.
        get: function () {
            var type = this.get('Content-Type');
            if (!type) {
                return '';
            }
            return contentType.parse(type).parameters.charset || '';
        },
        enumerable: true,
        configurable: true
    });
    // Return request header.
    HTTPRequest.prototype.get = function (field) {
        switch (field = field.toLowerCase()) {
            case 'referer':
            case 'referrer':
                return this.headers.referrer || this.headers.referer || '';
            default:
                return this.headers[field] || '';
        }
    };
    Object.defineProperty(HTTPRequest.prototype, "headers", {
        // Request header object. Alias as request.header.
        get: function () {
            return _headers.get(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "host", {
        // Get host (hostname:port) when present.
        // Supports X-Forwarded-Host when app.proxy is true, otherwise Host is used.
        get: function () {
            var proxy = _proxy.get(this);
            var host = proxy && this.get('X-Forwarded-Host');
            host = host || this.get('Host');
            if (!host) {
                return '';
            }
            return host.split(/\s*,\s*/)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "hostname", {
        // Get hostname when present.
        // Supports X-Forwarded-Host when app.proxy is true, otherwise Host is used.
        get: function () {
            var host = this.host;
            if (!host) {
                return '';
            }
            return host.split(':')[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "ip", {
        // Request remote address.
        // Supports X-Forwarded-For when app.proxy is true.
        get: function () {
            return this.ips[0] || '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "ips", {
        // When X-Forwarded-For is present and app.proxy is enabled an array of these ips is returned,
        // ordered from upstream -> downstream.
        // When disabled an empty array is returned.
        get: function () {
            var proxy = _proxy.get(this);
            var val = this.get('X-Forwarded-For');
            return proxy && (val ? val.split(/\s*,\s*/) : []);
        },
        enumerable: true,
        configurable: true
    });
    // Check if the incoming request contains the "Content-Type" header field,
    // and it contains any of the give mime types.
    // If there is no request body, null is returned.
    // If there is no content type, or the match fails false is returned.
    // Otherwise, it returns the matching content-type.
    HTTPRequest.prototype.is = function (types) {
        if (!types) {
            return typeis(this);
        }
        if (!Array.isArray(types)) {
            types = [].slice.call(arguments);
        }
        return typeis(this, types);
    };
    Object.defineProperty(HTTPRequest.prototype, "length", {
        // Return request Content-Length as a number when present, or undefined.
        get: function () {
            var len = this.get('Content-Length');
            if (len === '') {
                return;
            }
            return +len;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "method", {
        get: function () {
            return _method.get(this);
        },
        set: function (value) {
            _method.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "params", {
        get: function () {
            return _params.get(this);
        },
        set: function (value) {
            _params.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "path", {
        get: function () {
            return _path.get(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "protocol", {
        // Return request protocol, "https" or "http".
        // Supports X-Forwarded-Proto when app.proxy is true.
        get: function () {
            var proxy = _proxy.get(this);
            if (!proxy) {
                return 'http';
            }
            var proto = this.get('X-Forwarded-Proto') || 'http';
            return proto.split(/\s*,\s*/)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "query", {
        get: function () {
            return _query.get(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "secure", {
        // Shorthand for this.protocol == "https" to check if a request was issued via TLS.
        get: function () {
            return 'https' === this.protocol;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "subdomains", {
        // Return subdomains as an array.
        //
        // Subdomains are the dot-separated parts of the host before the main domain of the app.
        // By default, the domain of the app is assumed to be the last two parts of the host.
        // This can be changed by setting app.subdomainOffset.
        //
        // For example,
        //   * If the domain is "tobi.ferrets.example.com":
        //   * If app.subdomainOffset is not set, this.subdomains is ["ferrets", "tobi"].
        //   * If app.subdomainOffset is 3, this.subdomains is ["tobi"]
        get: function () {
            var offset = _subdomainOffset.get(this);
            var hostname = this.hostname;
            if (net.isIP(hostname)) {
                return [];
            }
            return hostname
                .split('.')
                .reverse()
                .slice(offset);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "type", {
        // Get request Content-Type void of parameters such as "charset".
        get: function () {
            var type = this.get('Content-Type');
            if (!type) {
                return '';
            }
            return type.split(';')[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "url", {
        // Get request URL.
        get: function () {
            return _url.get(this);
        },
        // Set request URL, useful for url rewrites.
        set: function (value) {
            _url.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPRequest.prototype, "inspect", {
        // Inspect implementation.
        get: function () {
            return this.toJSON();
        },
        enumerable: true,
        configurable: true
    });
    // Return JSON representation.
    HTTPRequest.prototype.toJSON = function () {
        return {
            headers: this.headers,
            method: this.method,
            url: this.url,
        };
    };
    return HTTPRequest;
}());
exports.HTTPRequest = HTTPRequest;
